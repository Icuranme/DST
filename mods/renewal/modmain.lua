-- If you're trying to use this as an example for your mod, you should know that I learned from the game source code itself, as well as other mods
-- Do note that you should learn how to program in LUA. Let me put it this way, I'm glad LUA wasn't my first programming language. But that's subjective.
-- see C:\Apps\Steam\steamapps\common\Don't Starve Together\data\databundles\scripts.zip
--   components/regrowthmanager.lua
--   prefab/carrot.lua
-- I believe in documenting code ;) Please do.

--------------------------------------------------------------------------
--[[DOCUMENTATION]]
--------------------------------------------------------------------------
--[[
The goal of this mod is to maintain the total number of some entities
while promising a minimum number of other entities. These numbers are
relative to the original number in the world, and we try to keep those
numbers in the biomes from which they came. An entity will respawn after
a delay, not immediately. The default delay is usually long, like a year.
So to be clear, when I say maintaining some number of entities, I don't
mean every moment of time. For example, a player could run out of boulders
to mine in the entire forest, but they'd regenerate the following year.

This mod contains 3 components that work together to maintain the world
1) WorldTracker: counts the entities generated by DST's
     worldgen, and the biomes it placed them in
2) Renewal: Spawns new entities near a given location after a configured
     delay
3) Renewable: gets added to entities we want to maintain new
     original positions

Unlike most mods I've read, I've broken the program up into modules. I
prefer OOP; sorry, not sorry. It's easier for me to stay organized. It's
probably easier to digest in chunks anyway.
  scripts/api: contains 'static utility classes
  scripts/model: contains a metatable to represent a LUA class
  scripts/components: DST standard. See the docs above

This file (modmain) defines entities in groups of prefab[rication]s. For
example, to maintain the number of mandrakes, we group "mandrake_planted"
and "mandrake" together. A mandrake_planted will start regrowing only
after a mandrake is burned or eaten, or a panflute is used up, etc. So,
we must group them together.

When a member of a group is spawned, then the count for that group is
incremented. When a member of a group is removed from the game, the count
for that group is decremented, and a timer is set for 2 seconds later to
determine if the total count is lower enough to trigger a respawn event.
The reason we delay it is due to current limitations of DST API.

Replacing callbacks (eg inst.components.workable:SetOnWorked()) may cause
this to break other mods and may easily fall out of date if Klei changes.
This mod uses event listeners instead of callbacks. We add a listeners to
entities in each group for OnRemove and AddPrefabPostInit to track
creation. We currently have no way to track entities from their origin. We're
not going to try too hard in this version of the mod to track such.

That should be enough info to understand the dataflows here:

1) [modmain] AddPrefabPostInit(prefab)
   -> [WorldTracker] increment group
2) [WorldTracker] TheWorld:ListenForEvent(OnRemove)
   -> decrement group count
   -> create count check timer 2 seconds
3) [WorldTracker] Count check timer fires
   -> if group size < initial group size
   ---> then TheWorld:PushEvent(regrow { prefab, location })
4) [Renewal] TheWorld:ListenForEvent(regrow { prefab, location })
   -> config = config[ groups[prefab] ]
   -> create respawn timer config.delay seconds (the logic involves tracking game time)
5) [Renewal] respawn timer fires
   -> tileType = Map:GetTile(initial location)
   -> find a spawn location near initial location that has the same tile type and away from players
   -> if we found a spawn location then spawn the entity there else recreate the timer as a slightly later time

Renewal works much like DST's regrowthmanager. It tracks game time
(which is how much time has passed in real life). But because some
entities regrow in less time under some conditions (eg plants respawn
faster when it's raining), it also tracks "simTime" for each group, where
simTime is the amount of time that has passed relative to how fast an
entity is to respawn. For example, if a flower is to respawn after 100
seconds, but regrows twice as fast when it's raining... if it's raining
for 20 seconds after it's picked, then the game time would be 20 and the
simTime for flowers would be 40. The flower would respawn at simTime 100.
--]]
--------------------------------------------------------------------------
--[[CONFIG]]
--------------------------------------------------------------------------
local LoggerFactory = require('common/logger').init("more_constant", true):enableTrace()
local Logger = LoggerFactory("modmain")

local ModMainConfig = require("model/ModMainConfig")
--local Controller = require('controllers/modcontroller')
local controller = require('controller')

--------------------------------------------------------------------------
--[[MAIN]]
--------------------------------------------------------------------------

local function return1()
  return 1
end

local function isSpring()
  return GLOBAL.TheWorld.state.isspring
end

local function isSummer()
  return GLOBAL.TheWorld.state.issummer
end

local function isWinter()
  return GLOBAL.TheWorld.state.iswinter
end

local function isRaining()
  return GLOBAL.TheWorld.state.israining
end

local function hasSnow()
  return 0 < GLOBAL.TheWorld.state.snowlevel
end

local function plants()
  return (isRaining() and 2)
      or (isSpring() and 1.5)
      or ((isWinter() or isSummer()) and 0.2)
      or 1
end

local function mushrooms()
  return (hasSnow() and 0)
      or plants()
end

local configs = {}

local function config(prefab)
  local result = ModMainConfig:new(prefab)
  table.insert(configs, result)
  return result
end

----plants
config("berrybush"):SetDelay(GetModConfigData("berrybush")):SetDelayModifierFn(plants):FromInitialLocation():SetMembers({ "dug_berrybush" })
config("berrybush2"):SetDelay(GetModConfigData("berrybush2")):SetDelayModifierFn(plants):FromInitialLocation():SetMembers({ "dug_berrybush2" })
config("berrybush_juicy"):SetDelay(GetModConfigData("berrybush_juicy")):SetDelayModifierFn(plants):FromInitialLocation():SetMembers({ "dug_berrybush_juicy" })
config("cactus"):SetDelay(GetModConfigData("cactus")):SetDelayModifierFn(return1)
config("oasis_cactus"):SetDelay(GetModConfigData("oasis_cactus")):SetDelayModifierFn(return1)
config("evergreen_sparse"):SetDelay(GetModConfigData("evergreen_sparse")):SetDelayModifierFn(return1)
----config("flower"):SetDelay(30):SetDelayModifierFn(plants) -- already done by regrowthmanager
config("flower_evil"):SetDelay(GetModConfigData("flower_evil")):SetDelayModifierFn(return1)
config("grass"):SetDelay(GetModConfigData("grass")):SetDelayModifierFn(plants):SetMembers({ "dug_grass", "grassgekko", "grass_water" })
config("livingtree"):SetDelay(GetModConfigData("livingtree")):SetDelayModifierFn(return1)
config("mandrake_planted"):SetDelay(GetModConfigData("mandrake_planted")):SetDelayModifierFn(plants):FromInitialLocation():SetMembers({ "mandrake_active", "mandrake", "cookedmandrake", "mandrakesoup" })
config("marsh_bush"):SetDelay(GetModConfigData("marsh_bush")):SetDelayModifierFn(plants)
config("marsh_tree"):SetDelay(GetModConfigData("marsh_tree")):SetDelayModifierFn(plants)
config("blue_mushroom"):SetDelay(GetModConfigData("blue_mushroom")):SetDelayModifierFn(mushrooms)
config("red_mushroom"):SetDelay(GetModConfigData("red_mushroom")):SetDelayModifierFn(mushrooms)
config("green_mushroom"):SetDelay(GetModConfigData("green_mushroom")):SetDelayModifierFn(mushrooms)
config("mushtree_small"):SetDelay(GetModConfigData("mushtree_small")):SetDelayModifierFn(mushrooms)
config("mushtree_medium"):SetDelay(GetModConfigData("mushtree_medium")):SetDelayModifierFn(mushrooms)
config("mushtree_tall"):SetDelay(GetModConfigData("mushtree_tall")):SetDelayModifierFn(mushrooms)
config("mushtree_moon"):SetDelay(GetModConfigData("mushtree_moon")):SetDelayModifierFn(return1)
config("reeds"):SetDelay(GetModConfigData("reeds")):SetDelayModifierFn(plants)
config("rock_avocado_bush"):SetDelay(GetModConfigData("rock_avocado_bush")):SetDelayModifierFn(plants):SetMembers({ "dug_rock_avocado_bush" })
config("sapling"):SetDelay(GetModConfigData("sapling")):SetDelayModifierFn(plants):SetMembers({ "dug_sapling" })
--config("twiggytree"):SetDelay(30):SetDelayModifierFn(plants)
--
----bees
config("beehive"):SetDelay(GetModConfigData("beehive")):SetDelayModifierFn(return1)
config("wasphive"):SetDelay(GetModConfigData("wasphive")):SetDelayModifierFn(return1)
--
----chess
config("bishop"):SetDelay(GetModConfigData("bishop")):SetDelayModifierFn(return1)
config("knight"):SetDelay(GetModConfigData("knight")):SetDelayModifierFn(return1)
config("rook"):SetDelay(GetModConfigData("rook")):SetDelayModifierFn(return1)
--
----spawners
config("catcoonden"):SetDelay(GetModConfigData("catcoonden")):SetDelayModifierFn(return1)
config("houndmound"):SetDelay(GetModConfigData("houndmound")):SetDelayModifierFn(return1)
config("mermhouse"):SetDelay(GetModConfigData("mermhouse")):SetDelayModifierFn(return1)
config("molehill"):SetDelay(GetModConfigData("molehill")):SetDelayModifierFn(return1)
config("moonglass_wobster_den"):SetDelay(GetModConfigData("moonglass_wobster_den")):SetDelayModifierFn(return1)
config("moonspiderden"):SetDelay(GetModConfigData("moonspiderden")):SetDelayModifierFn(return1)
--config("rabbithole"):SetDelay(30):SetDelayModifierFn(return1)
config("tallbirdnest"):SetDelay(GetModConfigData("tallbirdnest")):SetDelayModifierFn(return1)
--
----monsters/animals
config("carrat"):SetDelay(GetModConfigData("carrat")):SetDelayModifierFn(return1)
config("fireflies"):SetDelay(GetModConfigData("fireflies")):SetDelayModifierFn(return1)
config("fruitdragon"):SetDelay(GetModConfigData("fruitdragon")):SetDelayModifierFn(return1)
config("grassgekko"):SetDelay(GetModConfigData("grassgekko")):SetDelayModifierFn(return1)
config("lightninggoat"):SetDelay(GetModConfigData("lightninggoat")):SetDelayModifierFn(return1)
config("tentacle"):SetDelay(GetModConfigData("tentacle")):SetDelayModifierFn(return1)
--
----mineable
config("grotto_pool_big"):SetDelay(GetModConfigData("grotto_pool_big")):SetDelayModifierFn(return1):SetMembers({ "grotto_pool_small" })
config("moonglass_rock"):SetDelay(GetModConfigData("moonglass_rock")):SetDelayModifierFn(return1)
config("rock1"):SetDelay(GetModConfigData("rock1")):SetDelayModifierFn(return1)
config("rock2"):SetDelay(GetModConfigData("rock2")):SetDelayModifierFn(return1)
config("rock_flintless"):SetDelay(GetModConfigData("rock_flintless")):SetDelayModifierFn(return1):SetMembers({ "rock_flintless_med", "rock_flintless_low" })
config("rock_moon"):SetDelay(GetModConfigData("rock_moon")):SetDelayModifierFn(return1)
config("stalagmite_full"):SetDelay(GetModConfigData("stalagmite_full")):SetDelayModifierFn(return1):SetMembers({ "stalagmite_med", "stalagmite_low" })
config("stalagmite_tall_full"):SetDelay(GetModConfigData("stalagmite_tall_full")):SetDelayModifierFn(return1):SetMembers({ "stalagmite_tall_med", "stalagmite_tall_low" })

-- main starts here

-- simple version where we don't track initial location. Just publish creation and removal events
local function setupSimple(cfg)
  local groupName = cfg.group.product
  local function __setupSimple_subroutine(prefab)
    AddPrefabPostInit(prefab, function(inst)
      if GLOBAL.TheWorld.ismastersim then
        if Logger:isDebugEnabled() then
          if groupName == inst.prefab then
            Logger:debug("Prefab spawned: " .. inst.prefab)
          else
            Logger:debug("Prefab spawned: %s in group %s", inst.prefab, groupName)
          end
        end
        controller.IncreaseGroupCount(groupName, 1)

        inst:ListenForEvent("onremove", function()
          if Logger:isDebugEnabled() then
            if groupName == inst.prefab then
              Logger:debug("Prefab removed: " .. inst.prefab)
            else
              Logger:debug("Prefab removed: %s in group %s", inst.prefab, groupName)
            end
          end
          controller.DecreaseGroupCount(groupName, 1)

          local x, y, z = inst.Transform:GetWorldPosition()
          controller.ScheduleRespawn(groupName, x, y, z)
        end)
      end
    end)
  end

  __setupSimple_subroutine(cfg.group.product)
  for _, member in ipairs(cfg.members) do
    __setupSimple_subroutine(member)
  end
end

local function setupFromInitialLocation(cfg)
  AddPrefabPostInit(cfg.group.product, function(inst)
    if GLOBAL.TheWorld.ismastersim then
      inst:AddComponent("renewable")
    end
  end)

  for _, member in ipairs(cfg.members) do
    AddPrefabPostInit(member, function(inst)
      if GLOBAL.TheWorld.ismastersim then
        inst:AddComponent("renewable")
      end
    end)
  end
end

-- Setup All the groups
--
for _, cfg in ipairs(configs) do
  local group = cfg.group
  controller.DefineGroup({
    product = group.product,
    members = cfg.members,
    delay = group.delay,
    timeModFn = cfg.timeModFn
  })

  if 0 <= group.delay then
    if group.fromInitialLocation then
      setupFromInitialLocation(cfg)
    else
      setupSimple(cfg)
    end
  end
end
Logger:debug("Done configuring groups")
configs = nil

-- Add the main component to either the forest or cave
--
for _, prefab in ipairs({ "forest", "cave" }) do
  local firstPrefab = nil
  AddPrefabPostInit(prefab, function(inst)
    if GLOBAL.TheWorld.ismastersim then

      if firstPrefab then
        Logger:error("%s is the second to init after %s", prefab, firstPrefab)
        return
      end
      firstPrefab = prefab

      Logger:debug("adding components to %s", prefab)
      inst:AddComponent("moreconstant")
    end
  end)
end

--------------------------------------------------------------------------
--[[END RENEWAL MOD]]
--------------------------------------------------------------------------
